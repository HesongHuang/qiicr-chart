<!DOCTYPE html>
<html lang="en">
<head>
    <title>dc.js - Iowa Head and Neck Cancer Demo</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>
    <link rel="stylesheet" type="text/css" href="../css/mathbox.css">
    <script src="../js/jquery-1.11.2.min.js"></script>
    <script src="../js/mathbox-bundle.js"></script>
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">

    <style type="text/css">
      .dc-chart th {
        text-align: left
      }
      .dc-chart th,.dc-chart td {
          padding-left: 10px;
      }
      .dc-chart tr.dc-table-group td {
          padding-top: 4px;
          border-bottom: 1px solid black;
      }
      .dc-chart select {
          width: 150px;
      }
    </style>

</head>
<body>

<div id='volume-scatter' style="height: 600px; width: 100%"></div>
<div id="tumorSite-row-chart"></div>
<div id="sex-pie-chart"></div>
<div id="smoking-pie-chart"></div>
<div id="drinking-pie-chart"></div>
<div id="chewing-pie-chart"></div>
<div id="outcome-histogram-chart"></div>

<div id="measurement-table"></div>



<div>
<p>
Exploration of clinical variables vs quantitative imaging results for
patients studied by the University of Iowa as part of the NCI
Quantitative Imaging Network.
</p>

<p>
Chart key: Rater 1: red diamond; Rater 2: blue circle; Rater 3: green square.
</p>
<p>
Chart created using <a href=http://dc-js.github.io/dc.js/>dc</a>
and <a href=http://gitgud.io/unconed/mathbox>MathBox</a>.
</p>

<p>
This demo was created as part of the <a href=http://qiicr.org>QIICR project (U24 CA180918).</a>
</p>

<p>
The work is funded by <a href=http://www.nci.nih.gov>NCI</a>.
</p>
</div>

<script type="text/javascript" src="../js/d3.js"></script>
<script type="text/javascript" src="../js/crossfilter.js"></script>
<script type="text/javascript" src="../js/dc.js"></script>
<script type="text/javascript">

var ndx;
var patientIDDimension;

$(document).ready(function() {

  tumorSiteRowChart = dc.rowChart("#tumorSite-row-chart", "clinical");
  sexPieChart = dc.pieChart("#sex-pie-chart", "clinical");
  smokingPieChart = dc.pieChart("#smoking-pie-chart", "clinical");
  drinkingPieChart = dc.pieChart("#drinking-pie-chart", "clinical");
  chewingPieChart = dc.pieChart("#chewing-pie-chart", "clinical");
  outcomeHistogramChart = dc.barChart("#outcome-histogram-chart", "clinical");
  measurementTable = dc.dataTable("#measurement-table", "clinical");

  makeClinicalPlot = function(clinicalData) {

    ndx = crossfilter(clinicalData),
        allAccess = ndx.groupAll(),
        sexDimension = ndx.dimension(function(d) {return d.patient[0].sex;}),
        sexGroup = sexDimension.group(),
        tumorSiteDimension = ndx.dimension(function(d) {
          var tumorStaging = d.document[0].content[0].container[0].container[3];
          return tumorStaging.code[0].meaning;
        }),
        tumorSiteGroup = tumorSiteDimension.group(),
        outcomeDimension = ndx.dimension(function(d) {
          var patientCharacteristics = d.document[0].content[0].container[0].container;
          for (var characteristicIndex = 0; characteristicIndex < patientCharacteristics.length; characteristicIndex++) {
            if (patientCharacteristics[characteristicIndex].concept[0].meaning[0] === 'Disease Outcome') {
              codes = patientCharacteristics[characteristicIndex].code;
              if (codes) {
                for (var codeIndex = 0; codeIndex < codes.length; codeIndex++) {
                  if (codes[codeIndex].concept[0].meaning[0] === 'Followup status') {
                    return codes[codeIndex].meaning[0];
                  }
                }
              }
            }
          }
          return "unknown outcome";
        }),
        outcomeHistogram = outcomeDimension.group().reduceCount();

    var smokingDimension = ndx.dimension(function(d) {
      return (d.document[0].content[0].container[0].container[2].code[0].meaning[0]);
    }),
    smokingGroup = smokingDimension.group();

    var drinkingDimension = ndx.dimension(function(d) {
      return (d.document[0].content[0].container[0].container[2].code[1].meaning[0]);
    }),
    drinkingGroup = drinkingDimension.group();

    var chewingDimension = ndx.dimension(function(d) {
      try { return (d.document[0].content[0].container[0].container[2].code[2].meaning[0]); }
      catch (err) { return ("Not known");}
    }),
    chewingGroup = chewingDimension.group();

    patientIDDimension = ndx.dimension(function(d) {
      return (d.patient[0].id[0]);
    });

    var keyAndPercentValueLabel = function (total_value, d) {
        return "" + d.key + "  (" + d3.round(d.value/total_value*100.0, 0) + "%)";
    };

    tumorSiteRowChart
      .width(300)
      .height(540)
      .elasticX(true)
      .dimension(tumorSiteDimension)
      .group(tumorSiteGroup)
      .title( function(p) {return "Primary Tumor Site"} )
      .label(function(x) { return keyAndPercentValueLabel(allAccess.value(), x) })
      .legend(dc.legend().x(300).y(10).itemHeight(10).gap(3))
      .xAxis().ticks(4);

    sexPieChart
      .width(300)
      .height(300)
      .radius(100)
      .cx(170)
      .dimension(sexDimension)
      .group(sexGroup)
      .title( function(p) {return "Patient Sex"} )
      .legend(dc.legend().x(300).y(10).itemHeight(13).gap(5));

    smokingPieChart
      .width(300)
      .height(300)
      .radius(100)
      .cx(170)
      .dimension(smokingDimension)
      .group(smokingGroup)
      .title( function(p) {return "Smoking"} )
      .legend(dc.legend().x(300).y(10).itemHeight(13).gap(5));

    drinkingPieChart
      .width(300)
      .height(300)
      .radius(100)
      .cx(170)
      .dimension(drinkingDimension)
      .group(drinkingGroup)
      .title( function(p) {return "Drinking"} )
      .legend(dc.legend().x(300).y(10).itemHeight(13).gap(5));

    chewingPieChart
      .width(300)
      .height(300)
      .radius(100)
      .cx(170)
      .dimension(chewingDimension)
      .group(chewingGroup)
      .title( function(p) {return "Chewing"} )
      .legend(dc.legend().x(300).y(10).itemHeight(13).gap(5));

    outcomeHistogramChart
      .width(850).height(200)
      .dimension(outcomeDimension)
      .group(outcomeHistogram)
      .x(d3.scale.ordinal())
      .xUnits(dc.units.ordinal)
      .xAxisLabel("Outcomes")
      .yAxisLabel("# of Patients")
      .elasticY(true);

    measurementTable
      .width(850).height(400)
      .dimension(patientIDDimension)
      .group(function(d) {
        return ('');
      })
      .size(Infinity)
      .columns([
        { label : "ID",
          format : function(d) {
            return (d.patient[0].id[0]);
          }
        },
        { label : "Sex",
          format : function(d) {
            return (d.patient[0].sex[0]);
          }
        },
      ])
      .sortBy(function (d) {
        return (d.patient[0].id[0]);
      })
      .order(d3.ascending)
      .on('renderlet', function (table) {
          table.selectAll('.dc-table-group').classed('info', true);
      });

    dc.renderAll("clinical");
  };

});

/*
 * clinical data cohort selection
 */
var clinicalData;
$.getJSON("./clinical.json", function(data) {
  clinicalData = data;
  makeClinicalPlot(clinicalData);
});


/*
 * measurement data scatter plot
 */
var element = document.querySelector('#volume-scatter');
var mathbox = mathBox({
  element: element,
  plugins: ['core', 'controls', 'cursor', 'mathbox'],
  controls: {
    // Orbit controls, i.e. Euler angles, with gimbal lock
    klass: THREE.OrbitControls,
  },
});
if (mathbox.fallback) throw "WebGL not supported"

var three = mathbox.three;
three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

function makeMeasurmentPlot(options) {


  var plotMeasurements = options.plotMeasurements || {};
  var legendText = options.legendText || "No data";
  var patients = Object.keys(plotMeasurements).sort();
  var xDivisions = 10;
  if (patients.length) {
    xDivisions = 1 + patients.length;
  }

  // overall mathbox settings
  mathbox.remove("*"); // start with clean slate
  mathbox
    .set('focus', 2)
    .camera({ proxy: true, position: [0, 0, 2], });

  // view is a cartesian plotting area with
  // axes, a grid, label, etc
  var view = mathbox.cartesian({ range: [[0, 1], [0, 100]], scale: [2, 1], })
    .axis({ axis: 1, width: 3, end: false, })
    .axis({ axis: 2, width: 3, end: false, })
    .grid({ width: 1,  divideX: xDivisions, niceX: false, divideY: 10, })
    .scale({ axis: 2, divide: 5, })
    .ticks({ width: 3, size: 7, color: 'black', })
    .format({ digits: 2, })
    .label({ color: 'gray', zIndex: 1, offset: [-30, 0], })
    .text({ data: [legendText], })
    .label({ offset: [500, -40], zIndex: 1, color: 'black', });
  mathbox.select('axis').set('color', 'black');
  mathbox.select('grid').set('color', 'lightgray');

  // the scatter plot
  measurementPointsByObserver = {};
  var x = 0;
  var xIncrement = 1. / (1 + patients.length);
  for (var patientIndex in patients) {
    var patient = patients[patientIndex];
    x += xIncrement;
    var measurements = plotMeasurements[patient];
    for (var index = 0; index < measurements.length; index++) {
      var measurement = measurements[index];
      var observer = measurement.personObserverName;
      if (!measurementPointsByObserver[observer]) {
        measurementPointsByObserver[observer] = [];
      }
      measurementPointsByObserver[observer].push([x, measurement.measurementValue]);
    }
  }
  for (var observer in measurementPointsByObserver) {
    points = measurementPointsByObserver[observer];
    view
      .array({
        id : observer,
        data : points,
        width: points.length,
        channels: 2,
        items: 1,
        live: false,
      })
      .point(options.pointOptions[observer]);
  }
}

function filterAndPlotMeasurements() {
  var observerSet = new Set(["User1", "User2", "User3"]);
  var selectedPatients = patientIDDimension.top(Infinity);
  var patientIDSet = new Set();
  for (var patientIndex in selectedPatients) {
    var patientID = selectedPatients[patientIndex].patient[0].id[0];
    patientIDSet.add(patientID);
  }
  var volumesByPatient = {};
  for (var measurementIndex in measurementData) {
    measurement = measurementData[measurementIndex];
    if (!observerSet.has(measurement.personObserverName)) {
      continue;
    }
    if (measurement.finding != "Neoplasm, Primary") {
      continue;
    }
    if (measurement.activitySession != "1") {
      continue;
    }
    var patientID = measurement.patientID;
    if (patientIDSet.has(patientID)) {
      if (measurement.measurementConcept == "Volume") {
        if (!volumesByPatient[patientID]) {
          volumesByPatient[patientID] = [];
        }
        volumesByPatient[patientID].push(measurement);
      }
    }
  }
  var options = {
    plotMeasurements : volumesByPatient,
    pointOptions : {
      "User1" : { color: 'red', shape: 'diamond', size: 8, opacity: .75 },
      "User2" : { color: 'blue', shape: 'circle', size: 8, opacity: .75 },
      "User3" : { color: 'green', shape: 'square', size: 8, opacity: .75 },
    },
    legendText : 'Primary lesion volume (ml) per patient',
  };
  if (Object.keys(volumesByPatient).legnth == 0) {
    options.legendText = 'No data available';
  }
  makeMeasurmentPlot(options);
}

var measurementData = [];
$.getJSON("./measurements.json", function(data) {
  measurementData = data;
  measurementTable.on('preRedraw', filterAndPlotMeasurements);
  filterAndPlotMeasurements();
});

makeMeasurmentPlot({
  plotMeasurements : [],
  legendText : ['Waiting for data to load...'],
});

</script>
</body>
</html>

